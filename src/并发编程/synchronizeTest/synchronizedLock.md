## 使用内置锁（如，synchronized关键字）和显式锁（如，Lock接口的实现）各有优缺点
### 为什么内置锁（synchronized）在获取线程转储信息时会更有优势
1. 当我们执行线程转储（Thread Dump）来分析并发问题时，对于正在使用的内置锁，JVM会提供非常详细的信息。例如，它会告知我们哪个**线程持有了某个内置锁**，以及哪些**线程正在等待获取该内置锁**。这些信息对于理解和解决并发问题非常有帮助。
2. 原因是 **JVM 在内部管理这些内置锁**，并且 JVM 能够直接观察和控制它们的状态，因此它可以提供精确的转储信息。相比之下，**显式锁是通过 Java 代码库实现的**，通过调用Unsafe的本地方法实现，**JVM 并没有直接管理这些显式锁**。这导致 JVM 无法提供同样详细的信息，比如它无法明确知道哪个线程持有了某个显式锁，或者哪些线程正在等待获取该显式锁。显式锁的信息只能从这个**锁本身的API中获取**，而且**信息也相对有限**

### 区别和使用场景
1. **锁获取的灵活性**：显式锁提供了比内置锁更灵活的锁获取和释放模型。例如，Lock接口提供了tryLock方法，它在无法立即获得锁时不会阻塞，而是返回一个标示是否获得锁的布尔值。这与 synchronized 关键字的使用方式有本质的差别，后者在获得锁之前会一直阻塞当前线程。
2. **公平性**：默认情况下，内置锁和大部分显式锁都是"非公平"的，这意味着在锁被释放时，哪个线程能够获得锁是不可预知的。而对于ReentrantLock，你可以在构造函数中设置一个选择，来决定是使用公平锁还是非公平锁。公平锁会按照线程请求锁的顺序分配锁，虽然公平，但可能会影响整体的性能。
3. **条件变量**：这是显式锁的另一个优势，Lock接口提供了一个新的Condition类，用来替代传统的Object.wait()和Object.notify()方式，提供了更为丰富的线程间通信方式（例如，支持多路通知和更精细的通知控制）。
4. **性能**：对于最新版本的Java，内置锁和显式锁在性能上没有显著差异。但在早期Java版本中，使用synchronized关键字可能会导致意外的性能下降。