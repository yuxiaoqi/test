## java Thread 线程
### java.lang.Thread.interrupt
####  主要逻辑
* **设置线程的中断状态**：interrupt方法首先会设置线程的中断标记为 true。 这是通过一个称为 interrupt status 的内部标识来实现的。这个方法不会中断一个正在运行的线程，也就是说它不会影响线程的执行，只是改变了中断标记的状态。
* **中断阻塞状态的线程**：如果线程因为调用 **Object.wait(), Thread.join() 或 Thread.sleep()** （`后面还有补充`）方法而处于阻塞状态，那么它的中断状态将被清除，它还将收到一个 InterruptedException 以提醒该线程已经被中断。
  `  **java.lang.Thread#interrupt** 方法主要是通过修改线程的 interrupt status 并根据线程的状态来抛出 InterruptedException 来实现线程的中断的。
  在 interrupt 被调用后，中断状态会被置为 true，这是一个标记，表示该线程已经被中断了。然后，程序可以通过调用 Thread.currentThread().isInterrupted() 方法来检查当前线程是否被中断，以此来决定是否需要退出执行。但是值得注意的是，这个中断状态标记位不会影响到线程的运行，除非我们手动在代码中进行检查，并根据中断状态做出响应（比如停止线程）。`
#### 注意
1. 中断是**一种协作机制**，即一个线程不能强制中断另外一个线程，而必须由被中断的线程自身进行响应。
2. 执行 interrupt 方法的线程不能直接将目标线程停止运行，**目标线程内部需要不断的检查中断标记位**，以决定是否需要停止运行。
3. Thread.sleep 和 Object.wait 方法由于响应中断而抛出 InterruptedException，**同时会清除线程的中断标记**，所以如果不处理，那么在下一次循环开始时，就无法捕获这个中断，线程就会继续运行下去。

#### 线程在不同状态下，对中断的反应是不同的：
* **运行状态 Runnable**：如果线程处于运行状态，那么调用interrupt()方法会设置线程的中断标志位为true，但线程会继续运行，不会产生任何影响。程序需要手动检查线程的中断标志位，进行相关处理。
* **阻塞状态 Blocked**线程在等待锁释放从而进入同步区的过程中，**中断事件不会影响该线程。**
* **等待状态 Waiting**调用了方法Object.wait(), Thread.join()和LockSupport.park()的线程处于等待状态，此时调用线程的interrupt()方法，会抛出InterruptedException并清除中断标识。
* **定时等待状态 Timed Waiting**调用了如Thread.sleep(), Object.wait(long millis), Thread.join(long millis), LockSupport.parkNanos()或LockSupport.parkUntil()等具有指定等待时间的方法的线程，此时调用线程的interrupt()方法也会抛出InterruptedException并清除中断标识。
* **终止状态 Terminated**线程已经终止，无法被中断。
* **需要注意的是** 一旦线程被中断，**如果没有捕获这个中断就会继续运行下去** 。因此在编码的过程中，如果需要响应线程的中断请求，比如停止当前正在执行的任务，就需要在代码中显式的进行捕获处理，并指定对中断的响应操作。否则一个被中断的线程是会继续当前的操作直到正常结束。
  `  补充 在深入理解jvm3版中。能处于 blocked状态下的也只有使用 Synchronized 来同步的锁`

### 阻塞状态 Blocked 等待状态 Waiting对比详解
 **基本语义**
1. **WAITING**等待状态的线程正在等待其他线程进行特定操作，例如线程A调用了线程B的Object.wait()方法，线程A就会进入WAITING状态，进入等待池等待被唤醒。只有当其它线程调用此线程的Object.notify()或Object.notifyAll()方法时，线程A才会结束WAITING状态。这个过程是需要显式的代码进行唤醒的。
2. **BLOCKED**：如果某个线程正在等待一个monitor lock（也称为object的锁），以进入一个同步块/方法，或者重新进入一个同步块/方法，则称线程处于阻塞状态。阻塞状态的线程正在等待锁的释放，以便进入同步块或者方法的代码段。例如线程A进入一个synchronized同步坐标，由于线程B已经持有这个坐标的锁，线程A就会进入BLOCKED状态。这个过程只要锁释放，就会自动回到 Runnable 状态，是隐式的。
3. **简单说**，Blocked是被动的，它丢掉了CPU执行权后，再抢占不回来，除非等待的阻塞锁被释放。而Waiting是主动的，通过调用一些方法让线程放弃CPU并进入等待状态，等待其它线程通过notify()或者notifyAll()通知调度器该线程可以抢占CPU了。

**blocked状态下是是静止的吗？？？**

* 当一个Java线程进入BLOCKED状态时，它其实**并非完全静止**。在BLOCKED状态下，线程是没有在执行任务的，也没有在运行中，**它是在等待monitor lock的释放**，这个monitor lock可能是一个已经被其他线程占用的锁。这是一种"阻塞"状态，因为线程不能继续执行，直到获取所需的锁。</li>
* 比如说，一个线程T1在执行一个synchronized方法时，它占有了这个方法的锁。这时，如果另一个线程T2也想来执行这个synchronized方法，由于方法的锁已经被T1占用，所以T2就进入BLOCKED状态，直到T1执行完方法之后释放了锁，T2才能获取到锁进入RUNNABLE状态并执行方法。</li>
* 尽管在BLOCKED状态下，**线程看起来像是"静止"的**，但是它仍然需要由**操作系统进行管理**，并且随时准备进入RUNNABLE状态。线程调度器会在适当的时候唤醒这个线程，所以我们可以说，BLOCKED状态下的线程是被"暂时挂起"，等待获取需要的锁。</li>
* 总结一下，BLOCKED状态下的线程虽然不执行任务，但是它并非静止，而是被暂时挂起，待获取到所需的锁便可进入RUNNABLE状态并继续执行任务</li>

**blocked状态下不是一直在去轮询锁的占用情况吗?**
1. 在Java中，当一个线程试图获取一个内部锁（即monitor lock，常见于synchronized块）而无法获取时，它会进入BLOCKED状态。如你所提到的"轮询锁的占用情况"，实际上在Java，并非由线程自身不断地去主动检查锁是否可用，这样会消耗大量的系统资源，而是由操作系统和Java运行时系统负责。
2. 在具体实现上，线程**并不是持续不断地检查锁状态**，而是被挂起，进入等待状态直到其他线程释放锁。一旦其他线程释放锁，操作系统会唤醒一个或多个等待的线程（在后台自动完成），唤醒的线程然后试图重新获得锁。这个过程主要由Java虚拟机和操作系统共同管理和调度，并不需要开发者关心具体细节。
3. 所以，可以说在BLOCKED状态下的线程**并非一直在轮询锁的占用情况**，而是在**等待系统通知它锁已经被释放**，然后再去**尝试获取锁**，进入运行状态。在等待的期间，线程是被**挂起**的，**不占用CPU资源**。

**那在waiting状态在是静止的吗**?
1. 在Java中，线程的WAITING状态表示线程在等待另一个线程执行特定的动作。当线程进入WAITING状态时，它不会再消耗CPU时间来执行任务，也不会去主动轮询条件的变化，它会主动放弃所持有的资源（如CPU使用权），并且不会主动返回到RUNNABLE状态，它只能被其他线程唤醒。
2. 这种“唤醒”需要其他线程调用相应的notify()或notifyAll()方法来实现，因此我们通常说WAITING状态的线程在等待其他线程的通知。
3. 比如说，线程在完成了一些预备工作后，需要等待其他线程提供某些数据或状态变化，这时候，线程可以调用wait()方法，将自己置入WAITING状态，同时释放所有的同步资源，直到其他线程通知它继续执行。
4. 总的说来，WAITING状态下的线程是被挂起的，**不会占用CPU资源进行运行**，并且必须**依赖**其他线程来发出通知才能重新进入RUNNABLE状态进而执行任务。所以，我们可以说，**在等待某个条件时，WAITING状态下的线程几乎是静止的。**








### java.lang.Thread.UncaughtExceptionHandler
 **基础** java.lang.Thread.UncaughtExceptionHandler 接口有助于我们处理线程运行过程中未捕获的异常。这些异常通常是由于运行时错误或编程错误导致的。
1. **UncaughtExceptionHandler** 接口只有一个方法，即 public void uncaughtException(Thread t, Throwable e)。当 Thread 被杀死并且产生了一个未检查的异常时，这个方法会被调用。在本方法中，我们可以编写代码来处理这些异常：
   
2. `Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {
   public void uncaughtException(Thread t, Throwable e) {
   System.out.println(t + " 发生异常: " + e);
   }
   };`
3. 接下来，你需要使用 Thread 的 setUncaughtExceptionHandler 方法来注册这个未捕获异常处理者。
4. `Thread thread = new Thread(runnable);
   thread.setUncaughtExceptionHandler(handler);
   thread.start();`
5. 在上述代码中，我们首先创建了一个新的线程，然后设置它的未捕获异常处理者，最后启动这个线程。当线程运行过程中发生未捕获的异常时，我们定义的 uncaughtException 方法将被调用。
6. 这个接口确实提供了一种强大的方式来捕获和处理在线程运行过程中可能出现的任何未捕获的异常，极大地增强了代码的**健壮性**

### java.lang.Thread.yield
1. java.lang.Thread.yield() 是一个静态的原生（native）方法，它的作用是暗示当**前线程愿意放弃当前的 CPU 使用权**，让操作系统的线程**调度器重新**进行线程**调度**。运行到 yield() 方法的线程并**不会进入阻塞状态**，也不会释放任何**锁资源**，只是将自身的运行状态变为 **Ready（就绪**），即准备**再次进入 Run**（运行）状态。
2. **线程调度器**可以**自由地忽略** yield() 方法的调用，因此调用 yield() 并不能保证使其他线程真正得到运行机会。从 yield() 方法中返回，线程可能会立即再次获得 CPU 时间片继续执行，这在单核 CPU 环境中尤其明显。因此，yield() 方法的调用结果具有相当大的不确定性，以至于 JDK 文档中对它的描述是：“这是一个与具体实现和调度策略有关的方法”。
3. 关于 yield() 方法的一个**常见误解**是，它会让**当前线程**让步于**同优先级的线程**。实际上这**并不完全正确**。首先，**并非**所有的 JVM 实现都**支持**线程优先级，即使支持，yield() 也**不保证一**定让当前线程让步于同优先级的线程，甚至**可以让步**于优先级较低的线程。其次，由于 yield() 方法**既可以**让当前线程让步于高优先级的线程，**也可以**让步于同优先级或低优先级的线程，因此在一定程度上，yield() 方法可以避免优先级较高的线程长时间占用 CPU 而导致优先级较低的线程饿死。
4. 总的来说，Thread.yield() 在并发控制上的作用有限，它不能用于精确的线程同步控制，也不能保证有效地提高并发性能。在实际编程中，比起无法预测的 Thread.yield()，人们更常使用语义更丰富、更可控的线程同步工具，如 wait()/notify()，Lock，Semaphore 等。

### Thread上下文切换流程分析
**基础**
* 线程切换，也叫做上下文切换，是指CPU从执行一个线程切换到执行另一个线程的过程。线程切换是操作系统核心进行任务调度的主要方式，然而，它也会带来一定的性能开销。

**流程**
1. **保存当前线程的状态**：当需要切换到另一个线程时，操作系统必须首先**保存当前正在运行的线程的状态**，以便在以后可以恢复到这个状态继续运行。这包括的信息有：**程序计数器**（当前线程正在执行的代码的地址），**CPU寄存器的值**，**虚拟内存信息**等。
2. **选择下一个要运行的线程**：操作系统会根据线程的优先级和调度策略，选择下一个要运行的线程。常用的**线程调度策略**有：**轮询**（Round Robin）、**优先级调度**、**最短作业优先**、**先来先服务** 等。
3. **加载待执行线程的状态**：操作系统将切换到的线程的状态**加载到CPU**中，这包括：设置程序计数器到新线程的当前指令，设置CPU的寄存器为新线程的值，调整虚拟内存等。
4. **执行新线程**：在新线程的状态被加载以后，CPU开始执行新线程的代码。
5. 值得指出的是，线程切换要涉及到大量的**内核态与用户态之间的切换**，并且还有可能引发CPU的缓存失效，这是因为新线程可能会访问完全不同的内存地址，因此，线程切换通常会带来较大的性能开销。因此在设计并发程序时，我们要尽量减少不必要的线程切换。

### 线程上下文切换带来的 <span style="color: red;"> 用户态和核心态</span>

**基础定义**

用户态和核心态（也叫内核态）是操作系统中两种重要的CPU运行级别，这**两种模式用于控制程序对硬件和系统资源的访问**。不同的运行级别有不同的权限，这种设计有助于保护系统的安全性和稳定性。

1. **用户态**：在用户态下，程序**无法直接访问硬件和系统资源，也无法执行某些特权指令**。这意味着，运行在用户态的程序不能直接读写系统内核数据和硬件状态，而必须通过系统调用来请求内核提供服务。这是为了防止用户程序意外（或恶意）破坏系统状态。大多数用户层的应用程序，如浏览器、编辑器等，都是在用户态下运行。
2. **内核态**：内核态是CPU运行级别中**最高**的一级，**具有访问所有硬件的权限**。在内核态下，程序**可以执行任何CPU指令**，并直接访问系统的任何内存地址。操作系统核心的部分，例如设备驱动程序、文件系统和网络堆栈，通常在内核态下运行。

在多任务操作系统中，用户态和内核态的切换是非常普遍的。但是，状态切换本身会需要**一定的时间和资源**，因此，频繁的切换可能会对系统性能产生影响。为了提高效率，一般来说，操作系统都会尽量减少这种切换的次数。

### 状态切换会带来哪些<span style="color: red;"> 开销？</span>
 **基础描述**
 
状态切换，也就是从用户态切换到内核态，或是从内核态切换到用户态，对于操作系统来说都会带来一定的开销。这主要包括以下几方面

1. **时间开销**：每次上下文切换都会消耗一定的时间。此时间包括**保存**被中断线程的状态、在线程表中**找到下一个可以执行的线程**、以及**加载新线程的状态**等步骤。
2. **资源开销**：上下文切换会**消耗CPU资源**，因为CPU需要将当前线程的**状态**（CPU寄存器，程序计数器，堆栈指针等）**保存到内存**中，然后再从内存中恢复新线程的状态。
3. **缓存开销**：由于线程切换，新线程**可能**需要访问和之前线程**完全不同的内存地址**，导致**CPU缓存中的数据无法重用**，这会引起缓存不命中的现象，降低程序运行的效率。
4. **系统效率**：频繁的上下文切换会降低系统的整体效率，因为**CPU花费更多的时间在切换状态**，**而不是执行实际的用户任务**。

为了减少这些开销，许多操作系统优化了上下文切换的流程，并采用了预防和减少不必要的上下文切换的多种策略。例如，使用足够大的时间片**可以降低上下文切换的频率**，使用**线程池**可以重用已经创建的线程，**避免频繁的线程创建和销毁**。

### 哪些情况会导致<span style="color: red;"> 线程上下文切换？</span>
1. **阻塞**：
   * 等待输入输出操作（I/O操作）完成：例如，线程发起一个数据读取请求，需要等待硬盘的反馈信息，这时线程就会进入阻塞状态，等待I/O完成，因此会产生上下文切换。
   * **等待获取锁**：例如，当有多个线程竞争一个锁，只有一个线程可以成功获取，其他未成功获取锁的线程会进入阻塞状态，等待锁的释放，因此也会导致上下文切换。
2. **抢占/cpu时间片到期**：如果一个线程的**时间片用尽但仍在运行**，操作系统就会进行强制调度，先保存当前线程的上下文，再切换到下一个就绪的线程执行，这时就会产生上下文切换。
3. **线程结束**：例如，一个线程完成了它的任务自然结束，或者因为异常被终止，这时候需要切换到另一个线程，因此也会引发线程上下文切换。
4. **优先级变化**：
   * **线程优先级提升**：在优先级调度的系统中，如果一个优先级较高的线程就绪，系统**可能会选择**(<span style="color: red;">优先级只是建议操作系统,并不会一定就会执行</span> )暂停当前低优先级的线程，进行上下文切换，让优先级更高的线程获取CPU执行权。
   * **线程自主降低优先级**：为了避免长时间霸占CPU，一些线程在执行一段时间后，会自主降低自己的优先级，让出CPU，这也会引发上下文切换。
5. **手动切换**：例如，程序员在代码中显式调用了操作系统的调度函数，比如在Java中的**Thread.yield()，Thread.sleep**这时候就会主动让出CPU，从而引发上下文切换。
 
**补充**：**CPU时间片**
* **CPU时间片**，也被称为量子（Quantum），是**操作系统调度的基本单位**。每个线程被分配一段特定的CPU时间，也就是所说的时间片。时间片的长度**由操作系统确定**，并且可以根据系统及应用的不同进行调整。
* 在一个时间片内，线程可以借用CPU执行自己的任务。当**时间片用尽**，又有其他就绪的线程等待执行时，操作系统的**调度器就会让出CPU**，将其**分配给另一线程**，即进行所谓的"**上下文切换**"。
* **分配时间片的目的**是允许多个线程并发地运行在单个CPU上。这种并发运行可以提高系统的整体性能，因为一个线程在等待（例如I/O操作）时，CPU可以被其他的线程利用。
* 需要注意的是，上下文切换也是需要时间开销的，如果**时间片设置得过小**，**频繁**的上下文切换可能会导致**系统性能下降**。
* 
### 为什么要设计<span style="color: red;"> 用户态和核心态？</span>
设计用户态和核心态是为了保护操作系统的安全性和稳定性。主要目的有以下几点：

1. **权限管理**：内核态具有全权限，可以直接执行任何硬件指令和访问任意内存地址，这种模式通常被操作系统核心使用。而用户态的程序权限较低，不能直接执行敏感的硬件指令和访问受保护的内存区域，这种模式通常被应用程序使用。这就保证了应用程序不能随意更改系统级的资源。
2. **提高稳定性**：由于用户态程序无法直接访问硬件资源，因此即使应用程序发生错误，也不会对系统级资源造成严重影响，从而提高系统的整体稳定性。
3. **隔离资源**：用户态与核心态的切换提供了一种有效的资源隔离机制，能防止用户程序直接操作物理硬件，以避免产生冲突和破坏。
4. **提高安全性**：通过用户态和内核态的划分，可以防止恶意代码获取直接控制硬件的权限，提供了一定的系统安全保障。

通过以上设计，可以使得操作系统具有**良好的故障隔离性**，保障计算机系统的稳定运行，同时也可以有效防止恶意软件的攻击。


### 线程本地分配缓冲区 TLAB（Thread-Local Allocation Buffer）

* TLAB（Thread-Local Allocation Buffer）是J**ava Hotspot虚拟机中的术语**，是为了提高对象分配速度和线程并发性的一种**策略**。
* 在 HotSpot JVM 中，所有线程共享一块以 **Eden 区为主的堆内存**。当许多线程需要同时从堆上分配内存时（比如新建对象），就有可能出现**竞态条件**（Race Condition）-使用**乐观锁CAS**来完成并发安全。为了避免此类问题，通常需使用锁机制（如在分配之前申请、在分配之后释放），但是这会造成性能下降。
* TLAB 就是在这种场景下发挥作用的。**TLAB 是 Eden 区的一小部分**，被专门分配给某个特定的线程用于内存分配。所以当线程需要新建对象时，它可以直接在自己的 **TLAB 中分配内存**，而不需要通过锁机制获取共享资源。
* TLAB 提高了**内存分配的效率**，因为线程不再需要在共享的 Eden 区进行存储分配。此外，由于线程可以直接在自己的 TLAB 上操作，因此避免了竞态条件，提高了线程的并发性。然而，由于**每个线程都有自己的 TLAB**，所以会占用更多的内存。
* Java虚拟机参数 -XX:+UseTLAB 可以开启 TLAB 的使用，它在现代的 JVM 版本中通常是**默认开启**的。

**问题A：A在TLAB中分配好了访问到这个一个对象。在后面b线程可以访问到这个对象吗？**
1. 在Java中，线程间**可以共享**访问到堆内存中的对象。**即使对象是在特定线程的TLAB**（Thread-Local Allocation Buffer）内部分配的，只要有合适的引用路径（一个线程可以通过变量、字段或者数组等方式访问到该对象），其他线程也是可以访问到这个对象的。
2. 值得注意的是，虽然对象创建在一个线程的TLAB中，但是这并**不意味**着该对象只能由创建它的线程访问。**TLAB仅仅**是被用来**分配对象**的内存区域，一旦对象被创建并且有合适的**引用存在**，那么所有的线程**都可能访问到它**。
3. 例如，如果线程A在其TLAB中创建了一个对象并将其引用放入到一个**共享的**、线程安全的数据结构中（例如一个ConcurrentHashMap），那么线程B就可以从数据结构中获取到这个**引用并访问**到这个对象。
