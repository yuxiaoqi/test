## 事务传播性的基本介绍
当**前有事务**的则**加入**： 当前没有就三种：创建新的。不支持事物 抛出异常 总结就是 **有 没有 抛出异常**
  * **required（必须**）： 必需（必须）：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是最常见的选择。
    * **场景1**：在电商系统中，创建订单时，需要同时更新库存和用户积分。
    *  **场景2**：在银行系统中，转账操作需要同时更新两个账户的余额。
  * **supports（支持）**：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。
     * 场景1：在论坛系统中，浏览帖子时，可以在事务中读取以保证一致性，也可以不在事务中读取以提高性能。
     * 场景2：在报表系统中，生成报表通常不需要事务，但如果在事务中调用也不会有问题。
  * **mandatory（强制）**：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。即当前业务必须在现有的事务中运行，没有就要报错
    * 场景1：在工作流系统中，审批操作必须在已经开始的事务中执行，以确保操作的原子性。
    * 场景2：在财务系统中，**记账过程**必须在**现有的事务中进行**，以保**证数据的一致性**。
当**前有事务**的**则挂起**： 总是创建新的 总是以非事物 
  * **required_new（需要新的**）：**总**是开启一个**新的事务**。如果当前存在事务，则将当前事务挂起。
    * 场景1：在消息处理系统中，即使主流程失败，记录错误信息的操作**也应该成功**，因此**需要新的事务**。
    * 场景2：在用户注册过程中，发送验证邮件可能需要在不同的事务中执行，以确保邮件发送不受主事务结果的影响。
  * **not_supports（不支持）**：**总**是以**非事务**方式执行。如果当前存在事务，则将当前事务挂起。不需要消耗资源
    * 场景1：在数据导入功能中，可能需要执行一系列非事务操作，以避免长时间占用事务资源。
    * 场景2：在生成静态报告文件时，由于操作耗时且不需要事务支持，可以使用NOT_SUPPORTED。
**当前有事务，则抛出异常，总是以非事务**
  * **never（从不）**：总是以非事务方式执行。如果当前存在事务，则抛出异常。
    * 场景1：在执行系统维护或后台脚本时，确保这些操作不在事务中执行，以避免不必要的事务开销。
    * 场景2：在进行性能测试时，可能希望某些服务方法不在事务中运行，以准确测量非事务性能。
**nested（嵌套）**：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则表现同REQUIRED。
  * 如果当前没有事务，则行为类似于REQUIRED。
  * 如果当前存在事务，则在嵌套事务内执行。如果嵌套事务回滚，不会影响外部事务。
  * **嵌套事务**实际上是在单个物理事务的上下文中使用**保存点**来模拟的。这种方式提供了一定程度的灵活性，允许部分回滚而不是整个事务回滚，但它并**不等同于**创建了一个完全**独立的新事务**。
    * **示例**：适用于需要独立提交或回滚的情况，比如日志记录。外部事务失败时可以回滚内部事务，但内部事务失败通常不会导致外部事务失败。
    * 场景1：在一个复杂的订单处理流程中，某个子流程可能需要独立于主流程进行提交或回滚，例如订单的某个可选项。
    * 场景2：在一个大型批处理作业中，可能希望将作业分解为多个小的事务单元，每个单元成功或失败都不影响其他单元。

### 那我们来详细聊 嵌套事务如何实现 主事务和子事务的逻辑关系
  * NESTED事务传播行为允许一个事务在另一个事务的内部运行，形成一个嵌套事务。这是通过使用**保存点（savepoint）机制**来实现的，，而不会影响到外部（主）事务。如果外部事务失败并回滚，那么包括嵌套事务在内的所有操作都会被回滚。
  * **支持嵌套事务**，底层的**数据库**和**JDBC驱动**必须**支持保存点**。如果底层数据库不支持保存点，NESTED传播行为将不能使用。在这种情况下，尝试使用NESTED传播行为可能会导致异常。
  * 
  * **底层是如何实现保存点这个功能的** 在源码级别： **spring的 DataSourceTransactionManager**  **jdbc驱动com.mysql.jdbc.Connection**  **jdk在的rt.jar（是 启动类加载器加载的）中的 java.sql.Connection** 相互作用关系
    * **mysql是如何操作的**
      * 创建保存点：当执行**SAVEPOINT savepoint_name**;语句时，MySQL会在当前事务的日志中记录一个标记。这个标记包含了创建保存点时的所有活动事务的信息。
      * 回滚到保存点：执行**ROLLBACK TO savepoint_name**;时，MySQL会查找到对应的保存点标记，并撤销该标记之后的所有事务日志记录。这包括了所有的插入、更新、删除操作，以及可能的DDL变更。
      * 释放保存点：当执行**RELEASE SAVEPOINT savepoint_name**;时，MySQL会删除对应的保存点标记，并且释放与该保存点相关的所有资源。之后的事务回滚将不会考虑这个保存点。
      * **InnoDB存储引擎**中，这一过程是通过其**多版本并发控制（MVCC）**机制来辅助实现的。MVCC允许数据库维护多个版本的数据，这样即使在数据被修改的同时，也能够提供一致性的读取。当回滚到保存点时，InnoDB可以利用这些数据版本来恢复到保存点时的状态。 
  
