## count（*） count（1） count（列名）
 * **语义上区分**
   * COUNT(*)会计算**表中的所有行**，**不管**列中的值**是否为NULL**。
     * 在底层实现中，COUNT(*)不会检查任何特定的列，而是直接计算行数。因此，它通常被认为是这三种方法中最快的，尤其是当表中没有定义索引时。
     * 对于InnoDB存储引擎，由于聚簇索引的存在，COUNT(*)操作可以直接利用主键索引来快速计算行数。
   * COUNT(列名)**统计指定列中非NULL值的行数**。
     * 如果指定的**列名为主键**，由于主键不允许有NULL值，**COUNT(列名)与COUNT(*)的结果相同**。
     * 如果指定的列名不是主键，那么它将只计算该列中非NULL值的数量。
 * **性能上的分析**
 * **有优化器下的执行计划**
   * COUNT(1)和COUNT(*)的执行计划的一般特点
     * 全表扫描或索引扫描：
       * 如果没有可用的索引，数据库可能会执行全表扫描来计算行数。
       * **实际测试过 有唯一索引会用 唯一索引字段去计数，-> 没有则会用普通索引 -> 没有索引则会用主键 使用 PRIMARY** 
       * 如果有可用的索引，尤其是对于InnoDB这样的存储引擎，数据库可能会使用索引扫描来优化计数操作，因为索引通常比全表扫描更快。
     * 优化器转换：
       * 查询优化器可能会将COUNT(1)内部转换为COUNT(*)，因为它知道这两个查询的目的是相同的。这种转换使得优化器可以应用相同的优化规则和执行策略。
     * 不检查列值：
       * 在执行COUNT(1)或COUNT(*)时，数据库不需要检查表中的列值。它只需要计算行数，因此不会实际读取每一列的数据。
       * 利用存储引擎特性：
       * 对于InnoDB存储引擎，由于**数据是按照主键顺序存储的**，COUNT(*)可以直接利用**聚簇索引**来计算行数。COUNT(1)也会得到**同样的优化**。
       * 对于MyISAM存储引擎，由于它维护了一个内部的行计数器，COUNT(*)可以直接返回这个计数器的值，而不需要进行任何扫描。COUNT(1)同样会受益于这个特性。
 * **不同场景在如何使用**


## mysql count（1） 这个1 到底代表什么

* 在MySQL中，COUNT(1)中的数字**1实际上并没有特别的意义**，它只是一个常量值。COUNT()函数是一个**聚合函数**，用于计数。当你在COUNT()函数中使用数字1时，你告诉MySQL去计数所有行，其中1作为一个非NULL的常量值，确保每一行都被计数。
* 这里的关键点是**COUNT()函数计算**的**是非NULL值的数量**。因为1是一个确定的非NULL值，所以COUNT(1)会计算所有行，不论它们的其他列值是什么。这与COUNT(*)相同，后者专门用于**计数表中的所有行，而不考虑列的值**。
* 因此，**COUNT(1)、COUNT(0)、COUNT(-1)或COUNT(任何非NULL常量)**在**功能上**都是**等价**的，它们都会返回表中的行数。在实际执行中，MySQL的查询优化器会识别出这些表达式的目的都是为了计数，因此它们通常会被优化成相同的底层操作，执行效率也几乎相同。
* 在SQL标准中，**COUNT(*)是一个特殊的用法，它明确表示“计算所有行”**，并且是推荐的方式来计数表中的行数，因为它的**意图最为明确**。