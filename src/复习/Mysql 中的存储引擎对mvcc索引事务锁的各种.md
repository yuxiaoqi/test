## Explain 执行计划分析为入口
### 对于 type  ref Extra 这三列在做详细的分析，将每一列的所有类型都列举出来。并作出详细分析和性能介绍 和解决方案
* **type列**
  * type列显示了MySQL如何查找表中的行，它是一个重要的性能指标。以下是type列可能出现的值，按性能从好到差排序：
  * system：
    * 分析：表中只有一行（等同于系统表），这是最快的类型。
    * 性能：非常高。
    * 解决方案：通常不需要优化。
  * const：
    * 分析：通过索引一次就找到一行，例如使用主键或唯一索引查询单个行。
    * 性能：非常高。
    * 解决方案：通常不需要优化。
  * eq_ref：
    * 分析：对于每个索引键，表中只有一行匹配，通常用于主键或唯一索引扫描。
    * 性能：非常高。
    * 解决方案：通常不需要优化。
  * ref：
    * 分析：非唯一索引扫描，返回匹配某个单一值的所有行。
    * 性能：高。
    * 解决方案：检查是否可以通过修改查询或增加索引来改进。
  * fulltext：
    * 分析：全文索引扫描。
    * 性能：取决于文本大小和查询复杂性。
    * 解决方案：优化全文搜索条件，确保使用了全文索引。
  * ref_or_null：
    * 分析：类似于ref，但MySQL必须额外搜索包含NULL值的行。
    * 性能：中等。
    * 解决方案：检查是否可以避免使用NULL值的搜索。
  * index_merge：
    * 分析：使用了两个索引进行合并，然后根据索引合并的结果进行搜索。
    * 性能：中等。
    * 解决方案：考虑是否可以通过创建复合索引来改进。
  * unique_subquery：
    * 分析：在IN子查询中使用唯一索引。
    * 性能：中等。
    * 解决方案：通常不需要优化。
  * index_subquery：
    * 分析：在IN子查询中使用非唯一索引。
    * 性能：中等。
    * 解决方案：检查是否可以优化子查询。
  * range：
    * 分析：索引范围扫描，用于查找给定范围的行。
    * 性能：中等。
    * 解决方案：检查索引是否适合查询条件。
  * index：
    * 分析：全索引扫描，比全表扫描快，因为索引通常比数据文件小。
    * 性能：低。
    * 解决方案：检查是否可以通过更改查询或添加更适合的索引来避免全索引扫描。
  * ALL：
    * 分析：全表扫描，没有使用索引。
    * 性能：非常低。
    * 解决方案：考虑添加或优化索引，重写查询以减少扫描的数据量。
* **ref列**
  * ref列显示了MySQL如何使用索引。以下是ref列可能出现的情况：
  * 常数：使用常量值与索引进行比较，性能很高。
  * 字段名：使用表的列与索引进行比较，性能取决于索引的选择性。
  * 表达式：使用表达式的结果与索引进行比较，性能取决于表达式的复杂性和索引的选择性。
  * 性能影响：如果ref列显示为常数或使用高选择性的索引，性能通常较好。如果ref列显示为低选择性的索引或复杂表达式，可能需要优化。
   * 解决方案：优化索引选择，确保查询中使用的字段已经被索引。如果可能，避免在WHERE子句中使用复杂的表达式。
* **Extra列**
  * Extra列提供了关于MySQL如何解析查询的额外信息。以下是Extra列可能出现的值及其含义：
  * **Using index**：查询只使用了索引中的信息，没有读取实际的行数据，这是一种“覆盖索引”。
  * **Using where**：MySQL在检索行后进行了额外的过滤。
  * Using temporary：MySQL需要使用临时表来处理查询，通常在排序或分组操作时出现。
  * Using filesort：MySQL在内存或磁盘上进行排序，而不是按照索引顺序。
  * Using join buffer：MySQL使用了连接缓冲区来处理查询。
  * Impossible WHERE：WHERE子句的条件永远不会为真。
  * Select tables optimized away：在无需访问表的情况下优化了查询，通常发生在使用MIN()或MAX()函数时。
  * 性能影响：Using temporary和Using filesort通常表明查询性能不佳，因为它们涉及到额外的磁盘I/O或CPU资源消耗。Using index通常表示性能较好。
  * 解决方案：
  * 对于Using temporary和Using filesort，考虑重写查询以减少排序和分组的需要，或者优化索引以减少临时表的使用。
  * 对于Using index，通常不需要解决方案，因为这表示查询已经很高效。
  * 对于其他值，需要根据具体情况分析可能的性能问题，并进行相应的优化。

### Using where：MySQL在检索行后进行了**额外的过滤** 这个具体额外过滤是？和**回表**有关系吗？
 **基础**
   * Using where通常意味着MySQL在从数据源（**可能是全表扫描**或**索引扫描**）检索到行之后，需要对这些行应用**额外的过滤**来确保它们满足WHERE子句的条件。：
     * **常见场景**：
          * **索引扫描后的行过滤：（部分条件命中了索引）**
          当MySQL使用索引来定位数据行，但索引本身不包含足够的信息来满足查询条件时，它需要对数据行进行额外的检查。例如，如果查询使用了覆盖索引，但WHERE子句中的**某些条件不是索引的**一部分，MySQL需要**对每个通过索引定位的行**应用**WHERE子句的条件**。
          * 索引范围扫描：
          如果查询使用了索引范围扫描（比如使用了BETWEEN、>、<等操作符），MySQL可能会在索引中找到匹配的行，然后再次检查这些行以确保它们满足所有的WHERE子句条件。
          * **全表扫描：**
          当没有适用的索引时，MySQL会进行全表扫描，并对每一行应用WHERE子句的条件。在这种情况下，Using where表明MySQL正在对扫描到的每一行进行过滤。
          * **索引合并**：
          当MySQL使用多个索引进行查询，并且需要合并这些索引的结果时，它可能会在合并结果后应用WHERE子句的条件，这时也会出现Using where。
          * **连接查询**：
          在连接查询中，MySQL可能会使用索引来找到匹配的行，然后使用WHERE子句来过滤这些行，以确保它们满足连接条件。
          * **索引不是最左前缀**：
            如果查询使用了复合索引的一部分，但不是从最左边的列开始，MySQL可能会使用索引来检索数据，然后再应用WHERE子句的其他条件。
          * **索引选择性不足：（区分度不高）**
            即使查询使用了索引，如果索引的选择性不足（**即索引列中有大量重复的值**），MySQL可能仍然需要对检索到的行进行额外的WHERE条件过滤。
          * **部分索引扫描：**
            当查询条件**只能部分利用索引时**，MySQL可能会执行**部分索引扫描**，然后对**结果应用WHERE子句的剩余条件**。
          * **索引覆盖扫描后的过滤**：
            在索引覆盖扫描中，尽管查询可以通过仅访问索引来检索所有需要的列，但如果WHERE子句中的某些条件不能完全通过索引来评估，MySQL仍然需要对结果进行过滤。
          * **子查询或派生表**：
            如果查询包含子查询或派生表（使用FROM子句中的SELECT语句），MySQL可能需要对这些内部结果集应用WHERE子句的条件。
            优化器选择不使用索引：
            有时候，即使存在适用的索引，优化器也可能决定不使用它，因为它估计使用全表扫描更快。在这种情况下，Using where表示对全表扫描的结果进行了过滤。
     * 什么情况下 会同时出现 EXPLAIN结果中**同时**出现了**Using where和Using index**？
### 什么是**覆盖索引**? 什么是**回表**? 详细介绍 它如**何减少回表操作的需求**？
 * **覆盖索引**：
    * **定义** 覆盖索引是指一个**索引**包含了**查询中需要的所有数据**。换句话说，如果一个查询可以通过访问索引就能获取所有需要的信息，而无需访问数据表本身，那么这个索引就是一个覆盖索引。
    * 
 * **回表（Bookmark Lookup）**
    * **通用语义定义** 回表是指在使用**索引定位到数据行**之后，数据库需要再次访问**数据文件**来获取**不在索引中**的列数据的操作。这通常发生在查询使用了非覆盖索引的情况下。
    * **底层查询逻辑**
       * 回表（也称为“二次查找”或“书签查找”）是InnoDB存储引擎处理查询时可能进行的一个操作，它涉及到使用**非覆盖索引来定位行**，然后再通过**主键索引**来获取**完整的行数据**。这个过程在查询需要访问的数据不完全包含在索引中时发生。
         * **非覆盖索引**：
         当查询使用的索引不包含所有需要的数据时，这个索引被称为非覆盖索引。例如，如果查询需要选择除索引列之外的其他列，那么就需要回表来获取这些数据。
         * **聚簇索引：**
         InnoDB使用聚簇索引来存储数据，这意味着数据实际上是按照主键的顺序存储的。非主键索引（也称为二级索引）中的每个条目都包含对应行的主键值。
         * **回表操作**：
         当使用二级索引进行查询时，InnoDB首**先**在**二级索引中**查找满足条件的条目。**然后**，它使用这些条目中的**主键值去聚簇索引**中查找完整的数据行。这个过程就是回表。
    * **回表的性能影响**：
      * 回表操作可能会对查询性能产生显著影响，因为它涉及到**额外的磁盘I/O操作**。每次回表都需要从索引中**检索主键**，然后再到**数据文件中检索完整的行**。这个过程在行数较多时尤其耗时
    * **减少回表的性能开销**
      * **使用覆盖索引**：尽可能地使用覆盖索引，即**选择的列**都包含在**索引中**，这样就可以避免回表。
      * **优化查询**：调整查询**以减少需要回表的列**，或者重新考虑索引策略。
      * **合理设计索引**：在创建二级索引时，考虑包含**查询中常用的列**，以便索引能够覆盖更多的查询。